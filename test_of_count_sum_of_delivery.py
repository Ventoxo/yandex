import pytest
import random

from sum_of_delivery import count_of_delivery


class TestCountSumOfDeliveryPositive():

    @pytest.mark.parametrize('distance, profile, fragility, level_of_stress',
                             [(0, 'маленькие габариты', 0, 'очеНь высОкая загрУженность'),
                              (1.9999999, 'маленькие габариты', 0, 'default'),
                              (0.00000001, 'маленькие габариты', 0, 'default'),

                              (random.uniform(0, 2), 'маленькие габариты', 0, 'default'),
                              (random.uniform(0, 2), 'маленькие габариты', 0, 'очеНь высОкая загрУженность'),
                              (random.uniform(0, 2), 'маленькие габариты', 0, 'вЫсокАя загружеНность'),
                              (random.uniform(0, 2), 'маленькие габариты', 0, 'пОвышЕнная загружеНность'),

                              (1.9999999, 'большие габариты', 0, 'очеНь высОкая загрУженность'),
                              (0.00000001, 'большие габариты', 0, 'очеНь высОкая загрУженность'),
                              (random.uniform(0, 2), 'большие габариты', 0, 'default'),
                              (random.uniform(0, 2), 'большие габариты', 0, 'очеНь высОкая загрУженность'),
                              (random.uniform(0, 2), 'большие габариты', 0, 'вЫсокАя загружеНность'),
                              (random.uniform(0, 2), 'большие габариты', 0, 'пОвышЕнная загружеНность'),

                              (random.uniform(2, 10), 'маленькие габариты', 0, 'default'),
                              (random.uniform(2, 10), 'маленькие габариты', 0, 'очеНь высОкая загрУженность'),
                              (random.uniform(2, 10), 'маленькие габариты', 0, 'вЫсокАя загружеНность'),
                              (random.uniform(2, 10), 'маленькие габариты', 0, 'пОвышЕнная загружеНность'),
                              (9.9999999, 'большие габариты', 0, 'пОвышЕнная загружеНность'),
                              (2.00000001, 'большие габариты', 0, 'пОвышЕнная загружеНность'),
                              (9.9999999, 'маленькие габариты', 0, 'очеНь высОкая загрУженность'),
                              (2.00000001, 'маленькие габариты', 0, 'очеНь высОкая загрУженность'),

                              (random.uniform(2, 10), 'большие габариты', 0, 'default'),
                              (random.uniform(2, 10), 'большие габариты', 0, 'пОвышЕнная загружеНность'),

                              (random.uniform(10, 30), 'маленькие габариты', 0, 'default'),
                              (random.uniform(10, 30), 'маленькие габариты', 0, 'пОвышЕнная загружеНность'),
                              (29.9999999, 'маленькие габариты', 0, 'пОвышЕнная загружеНность'),
                              (10.00000001, 'маленькие габариты', 0, 'пОвышЕнная загружеНность'),
                              ])
    def test_minimum_sum(self, distance, profile, fragility, level_of_stress):
        assert count_of_delivery(distance, profile, fragility, level_of_stress) == 400

    """
    Продолжать это можно еще достаточно долго, кейсов тут хватает. 
    По этому же принципу, убрал пограничные значения, однако считаю, что они нужны, просто их наличие очевидно,
                                                                            а вот наличие других параметров - нет.
                                                                            
    Логика проста: так или иначе мы можем добиться одной суммы для разных показателей,
                                            тем самым не писать условные конструкции на каждый сантиметр кода, 
                                            а обернуть это в параметры.
    сделать негативные тесты достаточно просто: на каждый параметр задавать значение против условий задачи. 
    
    думаю, что ход моих мыслей вам уже понятен, поэтому считаю дальнейшее продолжение бессмысленным.
    Если вы захотите увидеть другие тест-кейсы или узнать, как бы я реализовывал более сложные конструкции, зовите на собес.
    
    tg: @Ventoxo
    pn: +79010488020
    """
